{
  "language": "Solidity",
  "sources": {
    "contracts/DCIPGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './governor.sol';\nimport './interfaces/dcip.sol';\n\ncontract DCIPGovernor is Governor {\n    using Timers for Timers.BlockNumber;\n    mapping(address => bool) public blockedAddresses;\n    uint16 public proposalReward;\n\n    constructor(IDCIP _token, uint16 _proposalReward) Governor(_token) {\n        proposalReward = _proposalReward;\n    }\n\n    function blockAddress(address adr) public onlyOwner returns (bool) {\n        blockedAddresses[adr] = true;\n        return true;\n    }\n\n    function unblockAddress(address adr) public onlyOwner returns (bool) {\n        blockedAddresses[adr] = false;\n        return true;\n    }\n\n    function proposalThreshold() public pure returns (uint256) {\n        return 80000000000e9;\n    }\n\n    function setProposalTreshhold(uint256 _threshold) public onlyOwner returns (bool) {\n        proposalTreshhold = _threshold;\n        return true;\n    }\n\n    function setVotingPeriod(uint64 period) public onlyOwner returns (bool) {\n        require(period >= 14400, 'Voting period cannot be less than 12 hours');\n        votingPeriodBlocks = period;\n        return true;\n    }\n\n    function propose(\n        string memory title,\n        string memory description,\n        uint256 fundAllocation\n    ) public override returns (uint256) {\n        require(blockedAddresses[_msgSender()] != true, 'Your address is blocked from making proposals');\n        require(getVotingWeight(_msgSender()) >= proposalThreshold(), 'Proposer votes below proposal threshold');\n        return super.propose(title, description, fundAllocation);\n    }\n\n    /**\n     * @dev If amount of votes cast passes the threshold limit.\n     */\n    function quorumReached(uint256 proposalId) public view virtual returns (bool) {\n        Proposal storage p = proposals[proposalId];\n        return p.votesForQuorum < (p.votesFor + p.votesAgainst);\n    }\n\n    function setVotesForQuorum(uint256 nrOfTokens) public virtual onlyOwner returns (uint256) {\n        require(nrOfTokens > 1000000e9, 'At least 1.000.000 DCIP is required');\n        votesForQuorum = nrOfTokens;\n        return votesForQuorum;\n    }\n\n    function getVotingWeight(address voter) public virtual override returns (uint256) {\n        return token.balanceOf(voter);\n    }\n\n    function hasVoted(address account, uint256 proposalId) public view returns (bool) {\n        return proposals[proposalId].hasVoted[account];\n    }\n\n    function getVote(address account, uint256 proposalId) public view returns (bool) {\n        return proposals[proposalId].vote[account];\n    }\n\n    function voteSucceeded(uint256 proposalId) public view returns (bool) {\n        Proposal storage p = proposals[proposalId];\n        return p.votesFor > p.votesAgainst;\n    }\n\n    function getProposal(uint256 proposalId)\n        public\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            string memory title,\n            string memory description,\n            uint256 fundAllocation,\n            Timers.BlockNumber memory voteStart,\n            Timers.BlockNumber memory voteEnd,\n            bool executed,\n            uint256 votesAgainst,\n            uint256 votesFor,\n            uint256 votesForQuorum,\n            ProposalState proposalState\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        ProposalState s = state(proposalId);\n        return (\n            p.id,\n            p.proposer,\n            p.title,\n            p.description,\n            p.fundAllocation,\n            p.voteStart,\n            p.voteEnd,\n            p.executed,\n            p.votesAgainst,\n            p.votesFor,\n            p.votesForQuorum,\n            s\n        );\n    }\n\n    function state(uint256 proposalId) internal view virtual override returns (ProposalState) {\n        Proposal storage proposal = proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.invalidated) {\n            return ProposalState.Invalidated;\n        } else if (proposal.voteStart.isPending()) {\n            return ProposalState.Pending;\n        } else if (proposal.voteEnd.isPending()) {\n            return ProposalState.Active;\n        } else if (proposal.voteEnd.isExpired()) {\n            return\n                quorumReached(proposalId) && voteSucceeded(proposalId)\n                    ? ProposalState.Succeeded\n                    : ProposalState.Defeated;\n        } else {\n            revert('Governor: unknown proposal id');\n        }\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        bool support,\n        uint256 weight\n    ) internal virtual override {\n        Proposal storage p = proposals[proposalId];\n        require(blockedAddresses[account] != true, 'Address blocked from voting');\n        require(p.hasVoted[account] == false, 'Vote has already been cast!');\n        require(weight >= 1, 'Invalid vote weight');\n        if (support == true) {\n            p.votesFor += weight;\n        } else {\n            p.votesAgainst += weight;\n        }\n        p.hasVoted[account] = true;\n        p.vote[account] = support;\n        emit VoteCast(account, proposalId, support, weight);\n    }\n\n    function invalidateProposal(uint256 proposalId) public onlyOwner returns (bool) {\n        Proposal storage p = proposals[proposalId];\n        p.invalidated = true;\n        return true;\n    }\n\n    function setProposalReward(uint16 _proposalReward) public onlyOwner returns (bool) {\n        proposalReward = _proposalReward;\n        return true;\n    }\n}\n"
    },
    "contracts/governor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport './interfaces/governor.sol';\nimport './libraries/ownable.sol';\nimport './interfaces/dcip.sol';\nimport './libraries/timers.sol';\nimport '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\nabstract contract Governor is Ownable, IGovernor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    IDCIP public token;\n\n    mapping(uint256 => Proposal) internal proposals;\n    uint256 proposalTreshhold;\n    uint256 public proposalCount;\n    uint256 public votesForQuorum;\n    uint64 public votingPeriodBlocks;\n\n    constructor(IDCIP _tokenAddress) {\n        token = _tokenAddress;\n        proposalCount = 0;\n        votesForQuorum = 25000000000000e9; /// Approxx 100 euros at current value\n        votingPeriodBlocks = 201600;\n    }\n\n    function propose(\n        string memory title,\n        string memory description,\n        uint256 fundAllocation\n    ) public virtual override returns (uint256) {\n        uint64 voteStart = block.number.toUint64();\n        uint64 deadline = voteStart + votingPeriodBlocks;\n        uint256 proposalId = proposalCount;\n\n        Proposal storage p = proposals[proposalCount];\n        p.id = proposalCount;\n        p.proposer = msg.sender;\n        p.title = title;\n        p.description = description;\n        p.fundAllocation = fundAllocation;\n        p.voteStart = Timers.BlockNumber(voteStart);\n        p.voteEnd = Timers.BlockNumber(deadline);\n        p.invalidated = false;\n        p.executed = false;\n        p.votesFor = 0;\n        p.votesAgainst = 0;\n        p.votesForQuorum = votesForQuorum;\n\n        emit ProposalCreated(proposalId, title, fundAllocation);\n\n        _countVote(proposalId, _msgSender(), true, getVotingWeight(_msgSender()));\n        proposalCount++;\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, bool support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        bool support\n    ) internal virtual returns (uint256) {\n        require(state(proposalId) == ProposalState.Active, 'Proposal is not currently active');\n\n        uint256 weight = getVotingWeight(account);\n        _countVote(proposalId, account, support, weight);\n        return weight;\n    }\n\n    function state(uint256 proposalId) internal view virtual returns (ProposalState);\n\n    function getVotingWeight(address voter) public virtual returns (uint256) {}\n\n    /**\n     * @dev Register a vote with a given support and voting weight.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        bool support,\n        uint256 weight\n    ) internal virtual;\n}\n"
    },
    "contracts/interfaces/dcip.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IDCIP {\n    function transfer(address to, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external pure returns (uint8);\n}\n"
    },
    "contracts/interfaces/governor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport '../libraries/timers.sol';\n\nenum ProposalState {\n    Pending,\n    Active,\n    Invalidated,\n    Defeated,\n    Succeeded,\n    Executed\n}\n\nstruct Proposal {\n    /// @notice Unique id for looking up a proposal\n    uint256 id;\n    /// @notice Creator of the proposal\n    address proposer;\n    /// @notice Title of the proposal\n    string title;\n    /// @notice Description of the proposal\n    string description;\n    /// @notice Funds to allocate\n    uint256 fundAllocation;\n    /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n    Timers.BlockNumber voteStart;\n    /// @notice The block at which voting ends: votes must be cast prior to this block\n    Timers.BlockNumber voteEnd;\n    /// @notice Current number of votes in favor of this proposal\n    bool executed;\n    /// @notice Flag marking whether the proposal has been invalidated\n    bool invalidated;\n    uint256 votesAgainst;\n    uint256 votesFor;\n    uint256 votesForQuorum;\n    mapping(address => bool) hasVoted;\n    mapping(address => bool) vote;\n}\n\n// enum AssetType {\n//     blockchain\n// }\n\n// struct Investment {\n//     /// @notice Type of the proposed asset\n//     AssetType assetType;\n//     /// @notice Number of DCIP allocated for investment\n//     uint256 fundAllocation;\n//     /// @notice Chain such as BSC, ETH, etc\n//     string chain;\n//     /// @notice address of token to buy\n//     address contractAddress;\n// }\n\ninterface IDCIPGovernor {\n    function propose(\n        string memory title,\n        string memory description,\n        uint256 fundAllocation\n    ) external returns (uint256);\n\n    function getProposal(uint256 proposalId)\n        external\n        view\n        returns (\n            uint256 id,\n            address proposer,\n            string memory title,\n            string memory description,\n            uint256 fundAllocation,\n            Timers.BlockNumber memory voteStart,\n            Timers.BlockNumber memory voteEnd,\n            bool executed,\n            bool invalidated,\n            uint256 votesAgainst,\n            uint256 votesFor,\n            uint256 votesForQuorum,\n            ProposalState proposalState\n        );\n\n    function castVote(uint256 proposalId, bool support) external returns (uint256);\n\n    function quorumReached(uint256 proposalId) external view returns (bool);\n\n    function voteSucceeded(uint256 proposalId) external view returns (bool);\n\n    function blockAddress(address adr) external returns (bool);\n\n    function unblockAddress(address adr) external returns (bool);\n\n    function proposalThreshold() external pure returns (uint256);\n\n    function setProposalTreshhold(uint256 _threshold) external returns (bool);\n\n    function setVotingPeriod(uint64 period) external returns (bool);\n\n    function setVotesForQuorum(uint256 nrOfTokens) external returns (uint256);\n\n    function getVotingWeight(address voter) external returns (uint256);\n\n    function hasVoted(address account, uint256 proposalId) external view returns (bool);\n\n    function getVote(address account, uint256 proposalId) external view returns (bool);\n}\n\ninterface IGovernor {\n    event ProposalCreated(uint256 id, string title, uint256 fundAllocation);\n    event VoteCast(address account, uint256 proposalId, bool support, uint256 weight);\n\n    function propose(\n        string memory title,\n        string memory description,\n        uint256 fundAllocation\n    ) external returns (uint256);\n\n    function castVote(uint256 proposalId, bool support) external returns (uint256);\n}\n"
    },
    "contracts/libraries/ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libraries/timers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary Timers {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/otcSale.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4; // 0.8+ protects us against int overflows, no need for safemath\n\nimport './libraries/ownable.sol';\nimport './interfaces/dcip.sol';\nimport './libraries/timers.sol';\nimport '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\n// Stores sum of all purchases made within cooldown period.\nstruct PurchaseInfo {\n    Timers.BlockNumber cooldownEnd;\n    uint256 totalBoughtInBNB;\n    bool isInitialized;\n}\n\ncontract OtcSale is Ownable {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    IDCIP public token;\n    uint256 public totalBNBEarned;\n    uint256 public minimumDepositBNBAmount = 1 wei;\n    uint256 public maximumDepositBNBAmount = 100000000 ether;\n    uint256 public tokenRate;\n    address private updater;\n\n    mapping(address => bool) public blacklistedWallets;\n    mapping(address => PurchaseInfo) public purchaseInfoCollection;\n    uint256 public periodicalPurchaseLimit; // Within cooldown\n    uint64 public blocksPerPeriod;\n\n    constructor(\n        IDCIP _tokenAddress,\n        address _updater,\n        uint256 _periodicalPurchaseLimit,\n        uint64 _blocksPerPeriod\n    ) {\n        token = _tokenAddress;\n        tokenRate = 999999999999999;\n        periodicalPurchaseLimit = _periodicalPurchaseLimit;\n        blocksPerPeriod = _blocksPerPeriod;\n        updater = _updater;\n    }\n\n    function setCooldownPeriod(uint64 blocks) public onlyOwner returns (uint64) {\n        blocksPerPeriod = blocks;\n        return blocksPerPeriod;\n    }\n\n    function setPeriodicalPurchaseLimit(uint256 bnb) public onlyOwner returns (uint256) {\n        periodicalPurchaseLimit = bnb;\n        return bnb;\n    }\n\n    function buy() external payable returns (bool) {\n        require(!blacklistedWallets[msg.sender], 'You are banned from the otcSale');\n        require(tokenRate > 1, 'Invalid tokenPrice');\n        require(\n            msg.value >= minimumDepositBNBAmount && msg.value <= maximumDepositBNBAmount,\n            'Purchase is too small or big'\n        );\n        require(\n            !isPeriodicalPurchaseOverLimit(msg.sender, msg.value),\n            'This purchase would exceed the allowed limits. Wait for the cooldown period to expire'\n        );\n\n        uint256 tokenAmount = ((msg.value * tokenRate) / ((10**18))) * (10**9);\n\n        require(tokenAmount > 0, 'You need to buy at least 1 DCIP');\n\n        require(token.balanceOf(address(this)) >= tokenAmount, 'Not enough DCIP available for sale'); // Enough DCIP balance for sale\n\n        // updatePurchaseData(msg.sender, msg.value);\n        // test\n\n        totalBNBEarned = totalBNBEarned + msg.value;\n        token.transfer(msg.sender, tokenAmount);\n        emit Bought(msg.sender, tokenAmount);\n        return true;\n    }\n\n    function updatePurchaseData(address adr, uint256 amount) internal returns (bool) {\n        PurchaseInfo storage d = purchaseInfoCollection[adr];\n        uint64 currentBlock = block.number.toUint64();\n        if (!d.isInitialized || d.cooldownEnd.isExpired()) {\n            // (re)create\n            d.totalBoughtInBNB = amount;\n            d.cooldownEnd = Timers.BlockNumber(currentBlock + blocksPerPeriod);\n            d.isInitialized = true;\n            return true;\n        } else {\n            d.totalBoughtInBNB = d.totalBoughtInBNB + amount;\n            d.cooldownEnd = Timers.BlockNumber(currentBlock + blocksPerPeriod);\n            return true;\n        }\n    }\n\n    function isPeriodicalPurchaseOverLimit(address adr, uint256 amount) public view returns (bool) {\n        return amount > periodicalPurchaseLimit;\n\n        // PurchaseInfo storage d = purchaseInfoCollection[adr];\n        // if (d.cooldownEnd.isExpired()) {\n        //     return false; // TODO: What happens here if it is not yet initialized for first buy?\n        // } else {\n        //     return (d.totalBoughtInBNB + amount > periodicalPurchaseLimit);\n        // }s\n    }\n\n    function getTokenRate() public view returns (uint256) {\n        return tokenRate;\n    }\n\n    function setUpdateAccount(address _updater) public onlyOwner returns (bool) {\n        updater = _updater;\n        return true;\n    }\n\n    function setTokenPrice(uint256 _rate) public returns (uint256) {\n        require(msg.sender == updater, 'Address is unauthorized');\n        require(_rate > 0, 'Rate must be higher than 0');\n        tokenRate = _rate;\n        return tokenRate;\n    }\n\n    function blackList(address wallet) public onlyOwner returns (bool) {\n        blacklistedWallets[wallet] = true;\n        return true;\n    }\n\n    function removeFromBlacklist(address wallet) public onlyOwner returns (bool) {\n        blacklistedWallets[wallet] = false;\n        return true;\n    }\n\n    function withdrawDCIP() external onlyOwner {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n    }\n\n    function withdrawBNB() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function getBNBEarnedAmount() external view returns (uint256) {\n        return totalBNBEarned;\n    }\n\n    event Bought(address indexed user, uint256 amount);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}